# The Coffee Machine (built by robots)

In 2022, Fito and I gave a presentation at RubyConf Mini about how complexity sneaks into an application, how to recognize it, and how to remove it permanently. We called the talk "The Coffee Machine Talk: A Brewer's Guide to Filtering out Complexity and Churn." The abstract went like this:

>Mechanical coffee machines are amazing! You drop in a coin, listen for the clink, make a selection, and the machine springs to life, hissing, clicking, and whirring. Then the complex mechanical ballet ends, splashing that glorious, aromatic liquid into the cup. Ah! C’est magnifique! 
>
>There’s just one problem. Our customers also want soup! And, our machine is not extensible. So, we have a choice: we can add to the complexity of our machine by jamming in a new dispenser with each new request; or, we can pause to make our machine more extensible before development slows to a halt.

In the talk, we write a small, make-believe coffee machine. With each commit, the code gets more complex. We keep the code DRY, because that's a good practice. But, by the time the machine can dispense coffee, tea, and cocoa, we've intertwined the three different algorithms, making it hard to figure out if a change to one recipe will also affect the other two.

So, we introduced the practice of Rehydration, or reintroducing duplication into overly DRY code in order to find the missing abstractions hiding in plain sight. Then, once the recipes are untangled, we introduce a factory to instantiate polymorphic beverage classes. And, in more recent versions of the talk, we show how to have the polymorphic classes register themselves with the factory. So, in the end, when we add soup, we do so without modifying ANY other classes.

It's a good talk. In some senses, it's a work of fan fiction, based on the works of Sandi Metz. It's also a love letter to The Open/Closed Principle.

In the last few months, we've been thinking a lot about how generative AI will affect the role of software developers. Will complexity and churn remain relavant in the future? Will the code even be relevant anymore?

So, we started playing with generative AI. At first, we thought that developer tools would, in the future, be able to accept a test, generate some code, run the test, and regenerate the code in a loop until the test passes. But, when we ran an experiment, to our amazement, several different LLMs were able to pass a small suite of tests just by prompting them with the tests (and a collaborating class).

This repo contains the tests, the original code from the presentation, a prompt that we send to several different LLMs, and the code generated by those LLMs. 

Consider this repo a "Hello, World!" for automated specification driven development.